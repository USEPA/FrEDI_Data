---
title: "Configure FrEDI SV Data"
author: "Industrial Economics, Inc."
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  rmarkdown::html_document:
    theme: spacelab
    toc: true
    toc_float: true
---

<style>
/* Simplified version of Bootstrap's responsive table CSS */
.table-responsive {
display: block;
width: 100%;
overflow-x: auto;
}

.table-responsive > table {
width: 100%;
}
</style>


```{r knitr setup, include=FALSE}
### The following parameters declare the options for compiling the Markdown document.
knitr::opts_chunk$set(
  include = T,     ### Evaluate and depict outputs of code chunks in the compiled document
  echo    = T,     ### Echo the commands of the code chunks in the compiled document
  message = FALSE, ### Don't include command-line messages output from evaluating code chunks
  cache   = FALSE, ### Don't cache the evaluation of code chunks
  warning = FALSE,  ### Don't include warnings from evaluating code chunks
  table.format = "html" 
)
```

## Overview

The purpose of this package is to configure the SV module for the R package after configuring the main FrEDI tool. First run "1_configure_FrEDI_main.Rmd"  prior to running "2_configure_FrEDI_SV.Rmd".

Load packages 

```{r loadPackages}
### Packages
require(tidyverse)
require(openxlsx)
require(devtools)
```


Set paths


```{r declare paths}
### Set print options
options(digits = 20)
### Set system paths
# projectPath      <- getwd()
projectPath      <- "."
today            <- format(Sys.Date(), "%Y%m%d")

### Path to fredi project
projectParentDir <- projectPath %>% file.path("..")
projectParentDir %>% list.files
frediPath        <- projectParentDir %>% file.path("FrEDI")

# ### Project configuration
# configPath       <- projectPath %>% file.path("config")
# # configFiles      <- configPath %>% list.files(".R")
# configFiles      <- "frediConfig.R"

### Code path
codePath         <- projectPath %>% file.path("R")
codeNames        <- codePath %>% list.files(".R")
# configLogPath    <- codePath %>% file.path("configLog")
# 
# ### Names for archive and use versions
# configFileName   <- "fredi_config"
# configArchName   <- configLogPath %>% file.path(configFileName) %>% paste(today, sep="_") %>% paste0(".rda")
# configUseName    <- codePath %>% file.path(configFileName) %>% paste0(".rda")

### Output path
dataOutPath      <- projectPath %>% file.path("data")
dataOutLog       <- dataOutPath %>% file.path("dataLog")
sysFileName      <- "sysdata"
# sysArchName      <- dataOutLog %>% file.path(sysFileName) %>% paste(today, sep="_") %>% paste0(".rda")
sysUseName       <- dataOutPath %>% file.path(sysFileName) %>% paste0(".rds")
```


## Update SV

### SV Sectors

List of SV sectors ("Air Quality - Premature Mortality", "Air Quality - Childhood Asthma", "Coastal Properties", "Extreme Temperature", "High Tide Flooding and Traffic", "Labor", "Roads")

Select a specific sector if not all sectors have been updated.


```{r c_sv_sectors}
codeNames; for(i in codeNames){ source(paste(codePath, i, sep="/")) }
frediPath %>% load_all

c_sv_sectors     <- try(get_sv_sectorInfo())
if("try-error" %in% class(c_sv_sectors)){c_sv_sectors <- NULL}

### Uncomment the following line and select specific sectors to update select sectors rather than all sectors
#c_sv_sectors     <- c("Labor","Roads","Extreme Temperature")
#c_sv_sectors     <- c("Air Quality - Premature Mortality", "Air Quality - Childhood Asthma") #put rest of sectors here
```

### Screening

Create a list with arguments on which aspects of the SV data to update (takes awhile to update impact functions so we divide the process into parts):

* `save`: Logical. Set `save=TRUE` to save the configuration lists to file
* `sv`: Logical. Set `sv=TRUE` to update the SV demographic data (good practice to update if `pop=TRUE` or `format=TRUE`)
* `pop`: Logical. Set `pop=TRUE` if the population data has changed
* `format`: Logical. Set `format=TRUE` if any aspect of the Excel template (layout, unit descriptions, etc.) has changed
* `impacts`: Logical. Set `impacts=TRUE` if any of the underlying sector impact data has changed
* `sectors`: Character vector. Specify which sectors to update if `impacts=TRUE` (defaults to all sectors)


```{r list_screening}
list_screening <- list(
  save     = TRUE,  ### Save SV
  sv       = TRUE,  ### Update SV demographic data
  pop      = TRUE,  ### Update SV population data
  format   = TRUE,  ### Update formats
  impacts  = FALSE, ### Update impact lists
  sectors  = c_sv_sectors
)
```


### Update Configuration Data

Run `createSVData()` with arguments created in `list_screening` to update SV configuration.

```{r run createSVData}
## Uncomment following six lines to create and save data and check the outputs
for(name_i in codeNames){ source(paste(codePath, name_i, sep="/")) }
time1       <- Sys.time()
test_svData <- createSVData(
  save    = list_screening$save, 
  sv      = list_screening$sv, 
  pop     = list_screening$pop,
  format  = list_screening$format, 
  impacts = list_screening$impacts, 
  sectors = list_screening$sectors,
  return  = TRUE
)
time2       <- Sys.time()
time_create <- time2 - time1; time_create
```

Check outputs:

```{r check test_svData}
test_svData %>% names
```

#### Examine SV Pop List

`iclusDataInfo`    has information about underlying ICLUS data
`iclusData`        has ICLUS data
`iclus_region_pop` has ICLUS region population scenario
`popProjList`      has functions for population projections

```{r svPopList names}
test_svData$svPopList %>% names
```

Look at `popProjList`:

* First level: Regions
* Second Level: 

```{r}
test_svData$svPopList$popProjList %>% names
```

Look at ICLUS data:

* 55,926 rows
* 15 columns

```{r}
test_svData$svPopList$iclusData %>% glimpse
```

Join SV Data and ICLUS Data

* Filter to years 2010, 2050
* `sample_iclusData` has 6214  rows
* `sample_svData`    has 72538 rows

```{r Subset data}
sample_iclusData <- test_svData$svPopList$iclusData %>% filter(year %in% c(2010, 2050))
sample_svData    <- test_svData$svData$svData
```

<!-- Missing data for three tracts. Which tracts are missing? -->


<!-- ```{r check_svTracts_na} -->
<!-- check_svTracts_na <- sample_svData %>%  -->
<!--   rename_at(.vars=c("fips", "county"), ~("sv" %>% paste(c("fips", "county"), sep="_"))) %>% -->
<!--   left_join(sample_iclusData, by=c("region", "state", "geoid10"))  -->
<!-- check_svTracts_na %>% glimpse -->
<!-- check_svTracts_na %>% filter(is.na("county_pop")) %>% dim -->
<!-- ``` -->

Calculate population

```{r sample_tractPop}
sample_tractPopCols <- c("region", "state", "geoid10", "iclus_county", "sv_county", "iclus_fips", "sv_fips", "region_pop", "ratioStatePop2Region", "ratioCountyPop2State", "ratioTract2CountyPop", "year")
# sample_tractPop  <- sample_iclusData %>% left_join(sample_svData, by=c("iclusgeoid", "county"))
sample_tractPop  <- sample_iclusData %>% 
  rename_at(.vars=c("fips", "county"), ~("iclus" %>% paste(c("fips", "county"), sep="_"))) %>%
  # left_join(sample_svData, by=c("region", "state", "geoid10")); sample_tractPop %>% glimpse
  left_join(sample_svData, by=c("region", "state", "geoid10")) %>%
  # sample_tractPop  <- sample_iclusData %>%
  #   rename_at(.vars=c("fips"), ~("sv" %>% paste(c("fips"), sep="_"))) %>%
  #   left_join(sample_svData, by=c("region", "state", "geoid10", "county")) %>%
  mutate(tract_pop = region_pop * ratioStatePop2Region * ratioCountyPop2State * ratioTract2CountyPop) %>%
  rename(sv_county = county, sv_fips = fips) %>%
  select(c(all_of(sample_tractPopCols))) %>% 
  arrange_at(.vars=c("region", "state", "geoid10", "year"))
# sample_tractPop %>% write.csv(file = resultsPath %>% file.path(today) %>% paste0("_svPop", ".", "csv"), row.names = F)
sample_tractPop %>% glimpse
c(nrow(sample_tractPop), (nrow(sample_svData)*2))
```


#### Examine SV Data List

```{r svDataList items}
test_svData$svDataList %>% names
```


#### SV Data List: SV Data

```{r test_svData_svData}
test_svData$svData %>% names
```

Check SV Data 

```{r test_svData}
test_svData$svData$svData %>% glimpse
```

#### 

```{r}
test_svData$svDataList[["sectorInfo"  ]] %>% glimpse
test_svData$svDataList[["svValidTypes"]] %>% glimpse
test_svData$svDataList[["svDemoInfo"  ]] %>% glimpse
```


#### Check SV Data Frames

Check dataframes:

```{r check_svItems}
check_svItems <- c("sectorInfo", "svSectorInfo") %>% 
  lapply(function(item_j, list_x=test_svData$svDataList){
    df_j    <- list_x[[item_j]]
    class_j <- df_j %>% class %>% paste(collapse=", ")
    item_j %>% paste0(": Classes = ", class_j) %>% print
    df_j %>% glimpse
  }) %>% unlist
```


Reform `svValidTypes`:


```{r view svValidTypes}
test_svData$svDataList[["svValidTypes"]] %>% glimpse
```

Reshape `svValidTypes`

```{r reshape svValidTypes}
test_svData$svDataList[["svValidTypes"]][["valid_popWeightCols"]][1] %>% str_split(", ") %>% unlist
test_svData$svDataList[["svValidTypes"]][["valid_popWeightCols"]][3] %>% str_match("children") %>% as.vector
test_svData$svDataList[["svValidTypes"]][["valid_popWeightCols"]] %>% str_match("children") %>% as.vector

test_svData$svDataList[["svValidTypes"]] %>% (function(df_x, weight_i = "children"){
  df_x   <- df_x %>% mutate(weightCol = weight_i)
  df_x   <- df_x %>% mutate(validType = valid_popWeightCols %>%  str_match(weightCol) %>% as.vector)
  return(df_x)
})
```


Add `svValidTypes` info to sector info:

```{r view svDemoInfo}
test_svData$svDataList[["svDemoInfo"]] %>% glimpse
```


Reshape `svDemoInfo`

```{r reshape svDemoInfo}
test_svData$svDataList[["svDemoInfo"]] %>% filter(colType %in% c("sv", "minority")) %>% 
  select(c("colName")) %>% rename_at(.vars=c("colName"), ~c("svGroupType"))

test_svData$svDataList[["svDemoInfo"]] %>% filter(colType %in% c("minority")) %>% 
  select(c("colName")) %>% mutate(validGroups = "none")

test_svData$svDataList[["svValidTypes"]] %>% 
  select(c("svGroupType", "valid_popWeightCols")) %>%
  rename_at(.vars=c("valid_popWeightCols"), ~c("validGroups"))
# test_svData$svDataList[["svDemoInfo"]] %>% filter(colType %in% c("minority"))
test_svData$svDataList[["svDemoInfo"]] %>% filter(colType %in% c("minority")) %>% 
  select(c("colName")) %>% rename_at(.vars=c("colName"), ~c("svGroupType")) %>% 
  mutate(validGroups = "none") %>% rbind(
    test_svData$svDataList[["svValidTypes"]] %>% 
      select(c("svGroupType", "valid_popWeightCols")) %>%
      rename_at(.vars=c("valid_popWeightCols"), ~c("validGroups"))
  ) %>% 
  (function(df_x, weight_i = "children"){
    df_x   <- df_x %>% mutate(weightCol = weight_i)
    df_x   <- df_x %>% mutate(validType = validGroups %>% str_match(weightCol) %>% as.vector)
    # df_x   <- df_x %>% mutate(valueAdj  = (1*!is.na(validType)) %>% na_if(0))
    df_x   <- df_x %>% mutate(valueAdj  = (1*!is.na(validType)))
    return(df_x)
  }) %>%
  mutate(x = 1, y = 2) %>%
  (function(dfx){
    dfx %>% mutate_at(.vars=c("x", "y"), function(colx, valx = dfx$valueAdj){colx * valx})
  })

```





## Update FrEDI Data

Use the following code to update the FrEDI system data with the SV configuration data.

```{r update_sysdata}
for(name_i in codeNames){ source(paste(codePath, name_i, sep="/")) }; codeNames
time3 <- Sys.time()
update_sysdata(
  save    = list_screening$save,
  sv      = list_screening$sv,
  # sv      = FALSE, 
  impacts = list_screening$impacts
)
time4       <- Sys.time()
time_update <- time4 - time3; time_update
```


Test FrEDI SV

```{r test get_sv_sectorInfo}
frediPath %>% load_all
get_sv_sectorInfo()
```



## Test Package

### Create Test Inputs

Create a list of inputs to test

1. Set specifications for inputs:

```{r inputSpecs}
### Values above maximum values
inputSpecs <- list(temps = list(min=-1, max=11), 
                   slr   = list(min=-1, max=270),
                   years = list(min=2000, max=2090))
```

Create list of inputs

```{r testInputs}
testInputs <- inputSpecs %>% (function(list_x){
  years_i   <- seq(list_x$years$min, list_x$years$max, by=1)
  n_years_i <- years_i %>% length()
  h_years_i <- (n_years_i / 2) %>% floor()
  ### Values below minimum
  min_i <- list(
    tempInput = data.frame(year = years_i, temp_C = list_x$temps$min),
    slrInput  = data.frame(year = years_i, slr_cm = list_x$slr$min)
  )
  
  ### Values above maximum values
  max_i <- list(
    tempInput = data.frame(year = years_i, temp_C = list_x$temps$max),
    slrInput  = data.frame(year = years_i, slr_cm = list_x$slr$max)
  )
  ### Step between minimum and maximum
  step_i <- list(
    tempInput = data.frame(year = years_i[1:h_years_i], temp_C = list_x$temps$min) %>%
      rbind(data.frame(year = years_i[(h_years_i + 1):n_years_i], temp_C = list_x$temps$max)),
    slrInput  = data.frame(year = years_i[1:h_years_i], slr_cm = list_x$slr$min) %>%
      rbind(data.frame(year = years_i[(h_years_i + 1):n_years_i], slr_cm = list_x$slr$max))
  )
  ### Increasing between minimum and maximum
  ramp_i <- list(
    tempInput = data.frame(year   = years_i, 
                           temp_C = seq(list_x$temps$min, list_x$temps$max, length.out=n_years_i)),
    slrInput  = data.frame(year   = years_i, 
                           slr_cm = seq(list_x$slr$min , list_x$slr$max, length.out=n_years_i))
  )
  
  ### Add to list
  list_i <- list(maxi = max_i, mini = min_i, step = step_i, ramp = ramp_i)
  ### Return
  return(list_i)
})
```


### Paths for Saving Results

```{r resultsPath}
# today <- "20221101"
# frediPath %>% file.path("..", "analysis", "qc") %>% list.files()
resultsPath <- projectParentDir %>% file.path("analysis", "qc", today)
if(!dir.exists(resultsPath)){resultsPath %>% dir.create}
```

Test SV tool:

* Iterates over sectors in `list_screening$sectors`
* Set `all=FALSE` to run first sector only
* Set `all=TRUE` to run all sectors
* Returns info for last sector

```{r test sv}
frediPath %>% load_all
test_sv <- 
  # get_sv_sectorInfo() %>% 
  # c_sv_sectors[1] %>%
  c("Labor") %>%
  # c("Coastal Properties") %>%
  # c("Roads") %>%
  #FrEDI::get_sv_sectorInfo() %>% #(function(x){x[which(!(x %in% c("Roads", "Labor", "Air Quality")))]}) %>%
  (function(
    sectors,
    all     = TRUE,
    # inputs  = testInputs[4],
    inputs  = NULL,
    outpath = resultsPath, 
    # .testing = TRUE,
    save = F, addDate = T, overwrite=TRUE
  ){
    ### SLR sectors
    c_slr <- c()#c_slr <- FrEDI::get_sv_sectorInfo(slrOnly = TRUE)
    ### Only run one sector
    if(!all){sectors <- sectors[1]}
    ### Scenarios
    c_scenarios_x <- inputs %>% names
    ### Create drivers if not null
    doInputs <- is.null(inputs)
    if(doInputs) {inputs_x <- NULL}
    else         {
      inputs_x <- c_scenarios_x %>% lapply(function(name_i, dataList = inputs){
        # name_j %>% print
        list_i   <- inputs[[name_i]]
        temp_i   <- list_i$tempInput
        #slr_i    <- list_i$slrInput
        inputs_i <- temp_i %>% mutate(scenario = name_i)#%>% left_join(slr_i, by = c("year")) 
        return(inputs_i)
      }) %>% (function(names_i){do.call(rbind, names_i)})
    } ### End else(doInputs)
    paste0("Input names: ", paste(inputs_x %>% names, collapse=", "), "...") %>% message()
    c_check_x <- inputs_x$scenario %>% unique; c_check_x %>% print
    check_x   <- all(c_check_x %in% c_scenarios_x) & all(c_scenarios_x %in% c_check_x)
    
    ### Run scenarios if all are present
    if(check_x){
      ### Iterate over sectors
      results_x <- sectors %>% lapply(function(sector_i, inputs_i=inputs_x){
        paste0("Running ", sector_i, "...") %>% message()
        sysTime_x <- Sys.time()
        ### Driver inputs
        if(doInputs) {
          if(sector_i %in% c_slr) {inputs_i <- inputs_i %>% select(c("year", "slr_cm", "scenario"))}
          else                    {inputs_i <- inputs_i %>% select(c("year", "temp_C", "scenario"))}
        } ### End if(doInputs)
        sv_i <- run_fredi_sv(
          sector      = sector_i, 
          driverInput = inputs_i,
          # .testing    = .testing,
          outpath     = outpath, save = save, addDate = addDate, overwrite=overwrite,
          silent      = FALSE
        )
        sysTime_y <- Sys.time(); (sysTime_y - sysTime_x) %>% print
        return(sv_i)
      }) %>% (function(sectors_i){do.call(rbind, sectors_i)})
      return(results_x)
    } ### End check_x
  })
test_sv %>% glimpse
```


Make sure at least some values are not missing:

```{r}
test_sv$scenario %>% unique
test_sv$aveRate_sv %>% (function(x, na=F){(!(x %>% is.na)) %>% which %>% length})
test_sv$driverValue %>% range
test_sv$aveRate_sv %>% (function(x, na=T){   x %>% is.na   %>% which %>% length})
test_sv$aveRate_sv %>% (function(x, na=F){(!(x == 0)) %>% which %>% length})
test_sv %>% filter(is.na(impPop_ref)) %>% select(svGroupType) %>% as.vector %>% unlist %>% unique
```

Check high risk populations (should be zero)


```{r check_sv}
check_sv <- test_sv %>% filter(regional_highRiskPop_sv > impPop_sv)
check_sv %>% glimpse
check_sv$svGroupType %>% unique
```


Or, test defaults:

```{r}
frediPath %>% load_all
test_sv <- "Labor" %>% run_fredi_sv(save=T, outpath = resultsPath, overwrite=T, addDate=T)
test_sv %>% write.csv(file = resultsPath %>% file.path("Labor.csv"), na = "")
```


## Build Package

If tests are passed, run `3_build_FrEDI.Rmd` to build the package.



